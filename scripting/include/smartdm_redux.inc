#if defined _smartdm_redux_included
	#endinput
#endif
#define _smartdm_redux_included

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Smart file downloader which seeks dependencies from the engine.
// Never download unused files or list individual files by hand again!
// Supports resolving dependencies for .mdl and .vmt files and precaching.
// This is a full rewrite by Alienmario of the original SmartDM by Zephyrus.
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// SmartDM.Add(...) is the main entry point and likely all you'll need.
// To enable debugging, add "#define SMARTDM_DEBUG" before this include.
// Useful debug command: dumpstringtables
// Note that all filenames will be turned lowercase before adding to downloads table.
// You should always keep all your custom content lower-cased to avoid issues (esp. with linux clients)
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Usually linux servers will not ship with shaders, prohibiting automatic detection
// of shader parameters needed to resolve .vmt material files.
// To overcome this, this include pairs with a cache file in SM's data folder.
// This file is automatically generated if missing and shaders are available (e.g. on Windows)
// Loading game specific (smartdm_shader_cache_<gamefoldername>.txt) or general (smartdm_shader_cache.txt)
// caches is attempted before querying the game engine.
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// To enable scanning the custom folder, smartdm needs to be added as path id in gameinfo.txt
// For example in HL2DM, the custom folder entry would look like this:
// game+mod+smartdm			hl2mp/custom/*
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Requirements:
//  - Min SourceMod version: 1.12 - build 6963 (older builds possible if shader cache already exists)
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


#include <sourcemod>
#include <sdktools>

#pragma newdecls required
#pragma semicolon 1

char SMARTDM_GAMEDATA[] = "smartdm";
#define SMARTDM_MAX_SHADER_NAME 128
#define SMARTDM_MAX_SHADER_PARAM_NAME 128

// Flag controlling whether to include default game content in resolved files.
// Only useful for alternative use cases, like resolving game file dependencies.
bool SmartDM_AllowDefaultContent;

// StringMap <ShaderName : StringMap<ShaderParamName : int>>
StringMap SmartDM_ShaderTexParams;

int SmartDM_Offs_numtextures;
int SmartDM_Offs_textureindex;
int SmartDM_Offs_mstudiotexture_t_sznameindex;
int SmartDM_Offs_sizeof_mstudiotexture_t;
int SmartDM_Offs_numcdtextures;
int SmartDM_Offs_cdtextureindex;
int SmartDM_Offs_numincludemodels;
int SmartDM_Offs_includemodelindex;
int SmartDM_Offs_mstudiomodelgroup_t_sznameindex;
int SmartDM_Offs_sizeof_mstudiomodelgroup_t;

methodmap SmartDM
{
	/**
	 * Simplest approach - Substitute for AddFileToDownloadsTable and precache functions.
	 */
	public static int Add(const char[] file, bool precache = false, bool preload = true)
	{
		SmartDM_FileSet files = new SmartDM_FileSet();
		SmartDM.AddEx(file, files, precache, preload);
		int numFiles = files.Size;
		files.AddToDownloadsTable();
		files.Close();
		return numFiles;
	}
	
	/** Alternative method for adding to the provided SmartDM_FileSet.
	 * Can be used for caching downloads and then calling SmartDM_FileSet.AddToDownloadsTable when needed.
	 * This has another advantage being that the files already in fileset won't need to be resolved for dependencies again.
	 */
	public static void AddEx(const char[] file, SmartDM_FileSet results, bool precache = false, bool preload = true)
	{
		SmartDM.Init();
		
		SmartDM_FileType ftype = SmartDM.ResolveFile(file, results);
		if (precache)
		{
			switch (ftype)
			{
				case SDM_FileType_Model:
					PrecacheModel(file, preload);
				case SDM_FileType_Material:
					PrecacheModel(file, preload);
				case SDM_FileType_Sound:
				{
					if (strlen(file) > 6)
					{
						PrecacheSound(file[6], preload);
					}
				}
			}
		}
	}

	public static SmartDM_FileType ResolveFile(const char[] file, SmartDM_FileSet results)
	{
		bool added = results.AddFile(file);
		int len = strlen(file);

		if (SmartDM.EndsWith(file, len, ".mdl"))
		{
			if (added)
			{
				SmartDM.ResolveMDL(file, results);
			}
			return SDM_FileType_Model;
		}
		else if (SmartDM.EndsWith(file, len, ".vmt"))
		{
			if (added)
			{
				SmartDM.ResolveVMT(file, results);
			}
			return SDM_FileType_Material;
		}
		else if (SmartDM.EndsWith(file, len, ".vtf"))
		{
			return SDM_FileType_Texture;
		}
		else if (SmartDM.EndsWith(file, len, ".mp3")
			|| SmartDM.EndsWith(file, len, ".wav")
			|| SmartDM.EndsWith(file, len, ".ogg"))
		{
			return SDM_FileType_Sound;
		}
		return SDM_FileType_Other;
	}

	/* RESOLVE */

	public static void ResolveMDL(const char[] file, SmartDM_FileSet results)
	{
		static const char exts[][] = {"phy", "sw.vtx", "dx80.vtx", "dx90.vtx", "vtx", "vvd"};

		#if defined SMARTDM_DEBUG
		LogMessage("Resolving MDL dependencies: %s", file);
		#endif

		int len = strlen(file);
		char baseName[PLATFORM_MAX_PATH];
		strcopy(baseName, len - 3, file);

		char buffer[PLATFORM_MAX_PATH];
		for (int i = 0; i < sizeof(exts); i++)
		{
			FormatEx(buffer, sizeof(buffer), "%s.%s", baseName, exts[i]);
			results.AddFile(buffer);
		}

		File hFile = OpenFile(file, "rb", true);
		if (!hFile)
		{
			LogError("Unable to read model file for resolving dependencies: %s", file);
			return;
		}
		SmartDM.ResolveMDLIncludes(hFile, results);
		SmartDM.ResolveMDLMaterials(hFile, results);
		hFile.Close();
	}

	public static void ResolveMDLIncludes(File hFile, SmartDM_FileSet results)
	{
		int includeModelCount;
		int includeModelOffset;

		hFile.Seek(SmartDM_Offs_numincludemodels, SEEK_SET);
		ReadFileCell(hFile, includeModelCount, 4);
		hFile.Seek(SmartDM_Offs_includemodelindex, SEEK_SET);
		ReadFileCell(hFile, includeModelOffset, 4);

		int temp;
		char includeModel[PLATFORM_MAX_PATH];
		for (int i = 0; i < includeModelCount; i++)
		{
			hFile.Seek(includeModelOffset + i * SmartDM_Offs_sizeof_mstudiomodelgroup_t + SmartDM_Offs_mstudiomodelgroup_t_sznameindex, SEEK_SET);
			ReadFileCell(hFile, temp, 4);
			FileSeek(hFile, temp - 4 - SmartDM_Offs_mstudiomodelgroup_t_sznameindex, SEEK_CUR);
			hFile.ReadString(includeModel, sizeof(includeModel));
			
			if (results.AddFile(includeModel))
			{
				SmartDM.ResolveMDL(includeModel, results);
			}
		}
	}

	public static void ResolveMDLMaterials(File hFile, SmartDM_FileSet results)
	{
		int materialCount;
		int materialOffset;
		int materialDirsCount;
		int materialDirsOffset;
		
		hFile.Seek(SmartDM_Offs_numtextures, SEEK_SET);
		ReadFileCell(hFile, materialCount, 4);
		hFile.Seek(SmartDM_Offs_textureindex, SEEK_SET);
		ReadFileCell(hFile, materialOffset, 4);
		hFile.Seek(SmartDM_Offs_numcdtextures, SEEK_SET);
		ReadFileCell(hFile, materialDirsCount, 4);
		hFile.Seek(SmartDM_Offs_cdtextureindex, SEEK_SET);
		ReadFileCell(hFile, materialDirsOffset, 4);

		int temp;
		char matDir[PLATFORM_MAX_PATH], matFile[PLATFORM_MAX_PATH];

		for (int i = 0; i < materialDirsCount; i++)
		{
			hFile.Seek(materialDirsOffset + i * 4 , SEEK_SET);
			ReadFileCell(hFile, temp, 4);
			FileSeek(hFile, temp, SEEK_SET);
			hFile.ReadString(matDir, sizeof(matDir));

			if (StrEqual(matDir, "/") || StrEqual(matDir, "\\"))
			{
				matDir = "";
			}

			for (int j = 0; j < materialCount; j++)
			{
				hFile.Seek(materialOffset + j * SmartDM_Offs_sizeof_mstudiotexture_t + SmartDM_Offs_mstudiotexture_t_sznameindex, SEEK_SET);
				ReadFileCell(hFile, temp, 4);
				FileSeek(hFile, temp - 4 - SmartDM_Offs_mstudiotexture_t_sznameindex, SEEK_CUR);
				hFile.ReadString(matFile, sizeof(matFile));

				Format(matFile, sizeof(matFile), "materials/%s%s.vmt", matDir, matFile);
				if (results.AddFile(matFile))
				{
					SmartDM.ResolveVMT(matFile, results);
				}
			}
		}
	}

	public static void ResolveVMT(const char[] file, SmartDM_FileSet results)
	{
		#if defined SMARTDM_DEBUG
		LogMessage("Resolving VMT dependencies: %s", file);
		#endif

		KeyValues kv = new KeyValues("");
		if (!kv.ImportFromFile(file))
		{
			LogError("Unable to read material file for resolving dependencies: %s", file);
			delete kv;
			return;
		}

		char buffer[PLATFORM_MAX_PATH];
		kv.GetSectionName(buffer, sizeof(buffer));
		SmartDM.Lowercase(buffer);

		StringMap textureParamsSet;
		if (SmartDM_ShaderTexParams.GetValue(buffer, textureParamsSet))
		{
			if (kv.GotoFirstSubKey(false))
			{
				do
				{
					kv.GetSectionName(buffer, sizeof(buffer));
					SmartDM.Lowercase(buffer);
					if (textureParamsSet.ContainsKey(buffer))
					{
						kv.GetString(NULL_STRING, buffer, sizeof(buffer));
						Format(buffer, sizeof(buffer), "materials/%s.vtf", buffer);
						results.AddFile(buffer);
					}
				}
				while (kv.GotoNextKey(false));
			}
		}
		delete kv;
	}
	
	public static void Init(const char[] szGamedata = SMARTDM_GAMEDATA)
	{
		if (SmartDM_ShaderTexParams)
			return;

		GameData gamedata = LoadGameConfigFile(szGamedata);
		if (gamedata == null)
			SetFailState("Could not load gamedata file \"%s\"", szGamedata);

		SmartDM_Offs_numtextures = gamedata.GetOffset("studiohdr_t::numtextures");
		SmartDM_Offs_textureindex = gamedata.GetOffset("studiohdr_t::textureindex");
		SmartDM_Offs_mstudiotexture_t_sznameindex = gamedata.GetOffset("mstudiotexture_t::sznameindex");
		SmartDM_Offs_sizeof_mstudiotexture_t = gamedata.GetOffset("sizeof(mstudiotexture_t)");
		SmartDM_Offs_numcdtextures = gamedata.GetOffset("studiohdr_t::numcdtextures");
		SmartDM_Offs_cdtextureindex = gamedata.GetOffset("studiohdr_t::cdtextureindex");
		SmartDM_Offs_numincludemodels = gamedata.GetOffset("studiohdr_t::numincludemodels");
		SmartDM_Offs_includemodelindex = gamedata.GetOffset("studiohdr_t::includemodelindex");
		SmartDM_Offs_mstudiomodelgroup_t_sznameindex = gamedata.GetOffset("mstudiomodelgroup_t::sznameindex");
		SmartDM_Offs_sizeof_mstudiomodelgroup_t = gamedata.GetOffset("sizeof(mstudiomodelgroup_t)");

		SmartDM_ShaderTexParams = SmartDM.ImportShaderCache();
		if (SmartDM_ShaderTexParams)
		{
			gamedata.Close();
			return;
		}

		SmartDM_ShaderTexParams = new StringMap();
		
		char szCreateMatSysIface[] = "CreateMatSysIface";
		StartPrepSDKCall(SDKCall_Static);
		if (!PrepSDKCall_SetFromConf(gamedata, SDKConf_Signature, szCreateMatSysIface))
			SetFailState("Could not obtain signature %s", szCreateMatSysIface);
		PrepSDKCall_AddParameter(SDKType_String, SDKPass_Pointer);
		PrepSDKCall_AddParameter(SDKType_PlainOldData, SDKPass_Pointer, VDECODE_FLAG_ALLOWNULL);
		PrepSDKCall_SetReturnInfo(SDKType_PlainOldData, SDKPass_Plain);
		Handle Call_CreateMatSysIface = EndPrepSDKCall();
		if (!Call_CreateMatSysIface)
			SetFailState("Could not prep SDKCall %s", szCreateMatSysIface);

		char szIfaceName[64];
		if (!gamedata.GetKeyValue("VMaterialSystem", szIfaceName, sizeof(szIfaceName)))
			SetFailState("Could not get interface verison for VMaterialSystem");

		Address pMatSysIface = view_as<Address>(SDKCall(Call_CreateMatSysIface, szIfaceName, 0));
		if (!pMatSysIface)
			SetFailState("Could not create %s interface", szIfaceName);

		StartPrepSDKCall(SDKCall_Raw);
		PrepSDKCall_SetFromConf(gamedata, SDKConf_Virtual, "CMaterialSystem::GetShaders");
		PrepSDKCall_SetReturnInfo(SDKType_PlainOldData, SDKPass_Plain);
		PrepSDKCall_AddParameter(SDKType_PlainOldData, SDKPass_Plain);
		PrepSDKCall_AddParameter(SDKType_PlainOldData, SDKPass_Plain);
		PrepSDKCall_AddParameter(SDKType_PlainOldData, SDKPass_Pointer, _, VENCODE_FLAG_COPYBACK);
		Handle Call_GetShaders = EndPrepSDKCall();

		StartPrepSDKCall(SDKCall_Raw);
		PrepSDKCall_SetFromConf(gamedata, SDKConf_Virtual, "IShader::GetName");
		PrepSDKCall_SetReturnInfo(SDKType_String, SDKPass_Pointer);
		Handle Call_GetName = EndPrepSDKCall();

		StartPrepSDKCall(SDKCall_Raw);
		PrepSDKCall_SetFromConf(gamedata, SDKConf_Virtual, "IShader::GetNumParams");
		PrepSDKCall_SetReturnInfo(SDKType_PlainOldData, SDKPass_Plain);
		Handle Call_GetNumParams = EndPrepSDKCall();

		StartPrepSDKCall(SDKCall_Raw);
		PrepSDKCall_SetFromConf(gamedata, SDKConf_Virtual, "IShader::GetParamName");
		PrepSDKCall_SetReturnInfo(SDKType_String, SDKPass_Pointer);
		PrepSDKCall_AddParameter(SDKType_PlainOldData, SDKPass_Plain);
		Handle Call_GetParamName = EndPrepSDKCall();

		StartPrepSDKCall(SDKCall_Raw);
		PrepSDKCall_SetFromConf(gamedata, SDKConf_Virtual, "IShader::GetParamType");
		PrepSDKCall_SetReturnInfo(SDKType_PlainOldData, SDKPass_Plain);
		PrepSDKCall_AddParameter(SDKType_PlainOldData, SDKPass_Plain);
		Handle Call_GetParamType = EndPrepSDKCall();

		StartPrepSDKCall(SDKCall_Raw);
		PrepSDKCall_SetFromConf(gamedata, SDKConf_Virtual, "IShader::GetFallbackShader");
		PrepSDKCall_SetReturnInfo(SDKType_String, SDKPass_Pointer);
		PrepSDKCall_AddParameter(SDKType_Edict, SDKPass_Pointer, VDECODE_FLAG_ALLOWNULL);
		Handle Call_GetFallbackShader = EndPrepSDKCall();

		StringMap shaderMap = new StringMap();
		Address shader;
		char shaderName[SMARTDM_MAX_SHADER_NAME];
		char fallback[SMARTDM_MAX_SHADER_NAME];
		char param[SMARTDM_MAX_SHADER_PARAM_NAME];
		
		for (int i = 0;; i++)
		{
			if (!SDKCall(Call_GetShaders, pMatSysIface, i, 1, shader))
				break;
			
			SDKCall(Call_GetName, shader, shaderName, sizeof(shaderName));
			SmartDM.Lowercase(shaderName);
			shaderMap.SetValue(shaderName, shader);
		}

		StringMapSnapshot snapshot = shaderMap.Snapshot();
		int len = snapshot.Length;
		
		for (int i = 0; i < len; i++)
		{
			snapshot.GetKey(i, shaderName, sizeof(shaderName));
			shaderMap.GetValue(shaderName, shader);

			StringMap textureParamsSet = new StringMap();
			SmartDM_ShaderTexParams.SetValue(shaderName, textureParamsSet);

			for (;;)
			{
				int numParams = SDKCall(Call_GetNumParams, shader);
				for (int j = 0; j < numParams; j++)
				{
					SmartDM_ShaderParamType_t pType = SDKCall(Call_GetParamType, shader, j);
					if (pType == SHADER_PARAM_TYPE_TEXTURE)
					{
						SDKCall(Call_GetParamName, shader, param, sizeof(param), j);	
						SmartDM.Lowercase(param);
						textureParamsSet.SetValue(param, 1);
					}
				}
				// also insert fallback shaders' parameters
				SDKCall(Call_GetFallbackShader, shader, fallback, sizeof(fallback), -1);
				if (fallback[0] == '\0')
					break;
				SmartDM.Lowercase(fallback);
				if (!shaderMap.GetValue(fallback, shader))
					break;
			}
		}
		SmartDM.ExportShaderCache(SmartDM_ShaderTexParams);

		delete snapshot;
		delete shaderMap;
		delete gamedata;
		delete Call_CreateMatSysIface;
		delete Call_GetShaders;
		delete Call_GetName;
		delete Call_GetNumParams;
		delete Call_GetParamName;
		delete Call_GetParamType;
		delete Call_GetFallbackShader;
	}

	public static bool ExportShaderCache(StringMap sourceMap)
	{
		if (!sourceMap.Size)
			return false;

		char path[PLATFORM_MAX_PATH];
		GetGameFolderName(path, sizeof(path));
		BuildPath(Path_SM, path, sizeof(path), "data/smartdm_shader_cache_%s.txt", path);
		if (FileExists(path))
		{
			return false;
		}

		KeyValues kv = new KeyValues("smartdm_shader_cache");

		StringMapSnapshot snapshot = SmartDM_ShaderTexParams.Snapshot();
		int len = snapshot.Length;
		int kbs;
		for (int i = 0; i < len; i++)
		{
			kbs = snapshot.KeyBufferSize(i);
			char[] shaderKey = new char[kbs];
			snapshot.GetKey(i, shaderKey, kbs);
			kv.JumpToKey(shaderKey, true);

			StringMap textureParamsSet;
			SmartDM_ShaderTexParams.GetValue(shaderKey, textureParamsSet);

			StringMapSnapshot snapshot2 = textureParamsSet.Snapshot();
			int len2 = snapshot2.Length;
			for (int j = 0; j < len2; j++)
			{
				kbs = snapshot2.KeyBufferSize(j);
				char[] paramKey = new char[kbs];
				snapshot2.GetKey(j, paramKey, kbs);
				kv.SetNum(paramKey, 1);
			}
			kv.GoBack();
			snapshot2.Close();
		}
		snapshot.Close();

		kv.Rewind();
		if (!kv.ExportToFile(path))
		{
			LogError("Failed to write smartdm shader cache to \"%s\"", path);
			kv.Close();
			return false;
		}
		kv.Close();
		return true;
	}

	public static StringMap ImportShaderCache()
	{
		char path[PLATFORM_MAX_PATH];
		GetGameFolderName(path, sizeof(path));
		BuildPath(Path_SM, path, sizeof(path), "data/smartdm_shader_cache_%s.txt", path);
		if (!FileExists(path))
		{
			BuildPath(Path_SM, path, sizeof(path), "data/smartdm_shader_cache.txt");
			if (!FileExists(path))
			{
				return null;
			}
		}
		
		KeyValues kv = new KeyValues("smartdm_shader_cache");
		if (!kv.ImportFromFile(path))
		{
			LogError("Failed to import smartdm shader cache from \"%s\"", path);
			kv.Close();
			return null;
		}

		StringMap shaderMap = new StringMap();
		char shaderName[SMARTDM_MAX_SHADER_NAME];
		char param[SMARTDM_MAX_SHADER_PARAM_NAME];
		if (kv.GotoFirstSubKey())
		{
			do
			{
				kv.GetSectionName(shaderName, sizeof(shaderName));
				SmartDM.Lowercase(shaderName);
				StringMap paramMap = new StringMap();
				shaderMap.SetValue(shaderName, paramMap);

				if (kv.GotoFirstSubKey(false))
				{
					do
					{
						kv.GetSectionName(param, sizeof(param));
						SmartDM.Lowercase(param);
						paramMap.SetValue(param, 1);
					} while (kv.GotoNextKey(false));
					kv.GoBack();
				}
			} while (kv.GotoNextKey());
		}
		kv.Close();
		return shaderMap;
	}

	/* UTILS */

	public static void NormalizePath(char[] str, int len, bool lowerCase = true)
	{
		ReplaceString(str, len, "\\", "/");
		if (lowerCase)
		{
			SmartDM.Lowercase(str);
		}
	}
	
	public static void Lowercase(char[] str)
	{
		int i = 0;
		while (str[i] != '\0')
		{
			str[i] = CharToLower(str[i++]);
		}
	}

	public static bool EndsWith(const char[] str, int realLen, const char[] suffix, bool caseSensitive = false)
	{
		int suffixLen = strlen(suffix);
		return (realLen >= suffixLen && StrEqual(str[realLen - suffixLen], suffix, caseSensitive));
	}

}

methodmap SmartDM_FileSet < StringMap
{
	public SmartDM_FileSet()
	{
		return view_as<SmartDM_FileSet>(new StringMap());
	}

	public bool AddFile(const char[] file)
	{
		char normalized[PLATFORM_MAX_PATH];
		strcopy(normalized, sizeof(normalized), file);
		SmartDM.NormalizePath(normalized, sizeof(normalized));
		
		if (!this.ContainsKey(normalized) && (FileExists(normalized, SmartDM_AllowDefaultContent, NULL_STRING) || FileExists(normalized, true, "SMARTDM")))
		{
			this.SetString(normalized, normalized);
			
			#if defined SMARTDM_DEBUG
			LogMessage("Adding file: %s", normalized);
			#endif

			return true;
		}
		return false;
	}

	public bool ContainsFile(const char[] file)
	{
		char normalized[PLATFORM_MAX_PATH];
		strcopy(normalized, sizeof(normalized), file);
		SmartDM.NormalizePath(normalized, sizeof(normalized));
		return this.ContainsKey(normalized);
	}

	public void AddToDownloadsTable()
	{
		StringMapSnapshot snapshot = this.Snapshot();
		int len = snapshot.Length;
		char path[PLATFORM_MAX_PATH];
		for (int i = 0; i < len; i++)
		{
			snapshot.GetKey(i, path, sizeof(path));
			this.GetString(path, path, sizeof(path));
			AddFileToDownloadsTable(path);
		}
		snapshot.Close();
	}
}

enum SmartDM_FileType
{
	SDM_FileType_None = -1,
	SDM_FileType_Other,
	SDM_FileType_Model,
	SDM_FileType_Material,
	SDM_FileType_Texture,
	SDM_FileType_Sound
}

enum SmartDM_ShaderParamType_t 
{
	SHADER_PARAM_TYPE_TEXTURE, 
	SHADER_PARAM_TYPE_INTEGER,
	SHADER_PARAM_TYPE_COLOR,
	SHADER_PARAM_TYPE_VEC2,
	SHADER_PARAM_TYPE_VEC3,
	SHADER_PARAM_TYPE_VEC4,
	SHADER_PARAM_TYPE_ENVMAP,	// obsolete
	SHADER_PARAM_TYPE_FLOAT,
	SHADER_PARAM_TYPE_BOOL,
	SHADER_PARAM_TYPE_FOURCC,
	SHADER_PARAM_TYPE_MATRIX,
	SHADER_PARAM_TYPE_MATERIAL,
	SHADER_PARAM_TYPE_STRING,
	SHADER_PARAM_TYPE_MATRIX4X2
};
